<h1>This is a signal practice</h1>
<p>Signals are nothing more than a wrapper around a value eg count=signal(1)</p>
<p>We have methods like Signals.set() to set the value and .update() to update the value which takes a callback function and the argument to the function is previous vlaue</p>
<h3>Types of signals</h3>
<p>There are two types of signals ie..</p>
<ul>
  <li>Writeabel</li>
  <li>Computed</li>
</ul>
<p>Till now we were only dealing with the writeable signals only.But what if we want to have a real-only signals to avoid updateion<br>
To create this type of signal use computed function eg.<br> doubleCounter=computed(()=>this.counter()*2)
<br>Value of Computed signal will automatically change as the orignal singal from which we derived it changes.
</p>
<h3>Dependency in the Signal</h3>
<p>
  If during the process of derivation we dont read a singal then it will not be a Dependency meaning if it changes the computed signal will not recompute the vlaue<br>
  eg. 
</p>
<button (click)="customEffect()">Click to update the signals</button>
<h3>I have learnt a lot of things about the signals </h3>
<ul>
  <li>How to destroy a effect</li>
  <li>About the untracked</li>
  <li>About the onCleanup argument that the effect takes</li>
</ul>
<h2>Rjx Interpol</h2>
<p>This is a stream of data that is updated using the pip operator (asyn) {{timmer|async}}</p>
<p>But this counter is made using the toSignal() method in Singla {{siganlCounter()}}</p>
<span>It was fun learning the toSignal() i learnt about</span>
<ul>
  <li>Asyn pipe</li>
  <li>null / default value</li>
  <li>using it outside constructor</li>
</ul>
<button (click)="cookie()">Get Cookie</button>
<button (click)="sendCookie()">Send Cookie</button>